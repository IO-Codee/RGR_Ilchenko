# Розрахункова-графічна робота

## з дисципліни «Архітектура та проєктування програмного забезпечення»
## на тему: «ШАБЛОНИ ПРОГРАМУВАННЯ»

# CREATIONAL PATTERN (FACTORY METHOD)

# Опис шаблону:
### Шаблон "Factory Method" - це створювальний шаблон проектування, який надає інтерфейс для створення об'єктів, але дозволяє підкласам вирішувати, який клас інстанціювати. Він сприяє слабкому зв'язуванню, абстрагуючи процес створення об'єктів та відкладаючи його до підкласів.
### Цей шаблон вирішує проблеми, такі як:
-  Як можна створити об'єкт, щоб підкласи могли перевизначити його подальшу та відмінну реалізацію?
-  Як можна відкласти інстанціювання об'єкта до підкласу?
## Елементи шаблону:
### Шаблон "Factory Method" складається з чотирьох основних елементів:
-  Product: Це інтерфейс або абстрактний клас, який визначає методи, які повинен реалізувати ConcreteProduct.
-  ConcreteProduct: Це класи, які реалізують інтерфейс Product.
-  Creator: Це абстрактний клас, який оголошує фабричний метод для створення продуктів.
-  ConcreteCreator: Це конкретні класи, які реалізують фабричний метод для створення конкретних продуктів.
 ```mermaid
classDiagram
    Creator <|-- ConcreteCreator
    Product <|-- ConcreteProduct
    Creator : +abstract factoryMethod()
    ConcreteCreator : +factoryMethod()
    Product : +operation()
    ConcreteProduct : +operation()



```
Рисунок 1 – Діаграма шаблону Factory Method

### Ці елементи взаємодіють таким чином, що Creator (або його підкласи) викликає фабричний метод для створення об'єкта, замість безпосереднього виклику конструктора. Це дозволяє підкласам змінити спосіб створення об'єкта (наприклад, перевизначивши, який клас інстанціювати).
### Переваги:
-  Слабке зв'язування: Шаблон Factory Method сприяє слабкому зв'язуванню між класами. Клас Creator не повинен знати, який саме клас буде інстанційований.
Інкапсуляція: Шаблон Factory Method інкапсулює процес створення об'єктів. Це спрощує зміну процесу створення без впливу на решту коду.
Повторне використання коду: Шаблон Factory Method сприяє повторному використанню коду, дозволяючи декільком класам поділитися спільним інтерфейсом.
### Недоліки:
-  Шаблон Factory Method може збільшити загальну кількість класів у системі. Кожен конкретний клас продукту також вимагає конкретного класу Creator.
-  Хоча переваги цього шаблону переважають недоліки, враховуючи зниження вартості ресурсів та збільшення масштабу застосувань, але все ж слабке зв'язування за допомогою додаткових об'єктів призводить до зниження продуктивності. 
### Особливості використання:
  Шаблон “Factory Method” відрізняється від інших шаблонів своєю гнучкістю та способом створення об’єктів. Він дозволяє підкласам вирішувати, який клас інстанціювати, що робить код більш гнучким, оскільки він не залежить від конкретних класів. Це особливо корисно, коли клієнт не знає, які конкретні класи він буде потребувати для створення об’єкта.
  Однак, цей шаблон може збільшити загальну кількість класів у системі, оскільки кожен конкретний клас продукту вимагає конкретного класу Creator. Тому, хоча Factory Method може зробити код більш гнучким, він також може зробити його більш складним через збільшення кількості класів.
### Особливості використання шаблону “Factory Method” в порівнянні з іншими шаблонами:
-  Factory Method використовує наслідування і дозволяє підкласам вирішувати, який клас інстанціювати.
-  Factory Method використовується, коли клієнт не знає, які конкретні класи він буде потребувати для створення об’єкта.


 
# STRUCTURUAL PATTERN (FLYWEIGHT)

### Опис шаблону:
Шаблон "Flyweight" - це структурний шаблон проектування, який мінімізує використання пам'яті та обробку, надаючи об'єкти, які всі ділять однакові дані, що економить пам'ять. Цей шаблон забезпечує об'єкти, які всі ділять однакові дані, тим самим економлячи пам'ять. Він часто використовується, коли ми маємо справу з великою кількістю об'єктів, які мають прості повторювані елементи, які використовували б много пам'яті, якщо вони були вбудовані індивідуально.
"Flyweight" зменшує кількість деталізованих об'єктів в системі, ділячись об'єктами. Якщо екземпляри класу, які містять однакову інформацію, можуть бути використані взаємозамінно, шаблон "Flyweight" дозволяє програмі уникнути витрат на кілька екземплярів, які містять однакову інформацію, ділячись одним екземпляром.
Корисний, коли ми маємо справу з великою кількістю об'єктів, які мають прості повторювані елементи, які використовували б много пам'яті, якщо вони були вбудовані індивідуально. Наприклад, класичним прикладом є структури даних, які використовуються для представлення символів у текстовому процесорі.
Клієнти можуть повторно використовувати об'єкти "Flyweight" і передавати зовнішній стан за потреби, зменшуючи кількість фізично створених об'єктів. Це дозволяє зменшити кількість об'єктів, що створюються, та покращити структуру об'єктів, необхідних для додатка.
Для шаблону Flyweight була створена Mermaid діаграма (див. рисунок 2):

### Елементи шаблону:
Шаблон "Flyweight" складається з наступних основних елементів:
-  Client: Об'єкт, який викликає виконання.
-  FlyweightFactory: Фабрика для створення та обміну об'єктами Flyweight.
-   lyweight: Відноситься до об'єктів, які ми хочемо повторно використовувати, щоб створити легші об'єкти.
-    ncreteFlyweight: Конкретні реалізації інтерфейсу Flyweight.
###Ці елементи взаємодіють таким чином:
  1.	Об'єкт Client викликає метод getFlyweight(key) на FlyweightFactory, який повертає об'єкт ConcreteFlyweight.
  2.	Після виклику методу operation(extrinsicState) на повернутому об'єкті ConcreteFlyweight, Client знову викликає getFlyweight(key) на FlyweightFactory.
  3.	FlyweightFactory повертає вже існуючий об'єкт ConcreteFlyweight.
### Ці елементи дозволяють клієнтам повторно використовувати об'єкти Flyweight і передавати зовнішній стан за потреби, зменшуючи кількість фізично створених об'єктів.
 ```mermaid

classDiagram
    FlyweightFactory <|-- ConcreteFlyweight
    Flyweight <|-- ConcreteFlyweight
    Client -- FlyweightFactory
    Client -- Flyweight
    class FlyweightFactory{
        +getFlyweight(key)
    }
    class Flyweight{
        +operation(extrinsicState)
    }
    class ConcreteFlyweight{
        +operation(extrinsicState)
    }
    class Client{
        -extrinsicState
    }
```
Рисунок 2 – Діаграма шаблону Flyweight

### Особливості використання:
Шаблон "Flyweight" використовується в різних сценаріях, особливо коли потрібно ефективно керувати великою кількістю об'єктів:
-  Графічні та обробка зображень: У графічних додатках, таких як комп'ютерні ігри або програмне забезпечення для обробки зображень, шаблон "Flyweight" може використовуватися для управління графічними елементами, такими як текстури, спрайти або шрифти.
-  Стиснення даних: Ціль шаблону "Flyweight" - зменшити використання пам'яті, ділячись якомога більшою кількістю даних, тому він є хорошою основою для алгоритмів стиснення без втрат. У цьому випадку кожен об'єкт "Flyweight" діє як вказівник, а його зовнішній стан - це інформація, залежна від контексту.
  -   ешування даних: Шаблон "Flyweight" може бути ефективно використаний у фреймворках кешування та зберігання даних для оптимізації використання пам'яті та покращення продуктивності. Шляхом спільного використання загальних структур даних між різними сутностями, шаблон "Flyweight" зменшує використання пам'яті та покращує загальну ефективність обробки даних.
  -  лика кількість подібних об'єктів: Шаблон "Flyweight" використовується, коли потрібно створити велику кількість подібних об'єктів. Це може бути корисним, наприклад, у текстових редакторах, де кожен символ є об'єктом "Flyweight", який ділить дані, необхідні для відтворення.
#### Переваги:
-  Ефективне використання пам'яті: Основна перевага шаблону "Flyweight" полягає в його здатності значно зменшити використання пам'яті. Загальна використання пам'яті мінімізується шляхом спільного використання загальних частин об'єктів (внутрішній стан) серед кількох екземплярів.
-  Підвищення продуктивності: Шаблон "Flyweight" може покращити продуктивність застосування, зменшуючи кількість об'єктів, що створюються, та покращуючи структуру об'єктів, необхідних для додатка.
-   овторне використання об'єктів: Шаблон "Flyweight" дозволяє повторно використовувати об'єкти, що зменшує кількість об'єктів, що створюються.
### Недоліки:
  даткові витрати на виконання: Шаблон "Flyweight" може ввести додаткові витрати на виконання через операції, необхідні для управління та пошуку об'єктів "Flyweight". Це може потенційно сповільнити час доступу, особливо якщо система часто отримує доступ до великої кількості об'єктів "Flyweight".
  ладність: Шаблон "Flyweight" може зробити код більш складним, оскільки він вимагає управління спільними об'єктами та передачі зовнішнього стану.



 
# BEHAVIORAL PATTERN (Chain of responsibility)

### Опис шаблону:
Шаблон "Chain of Responsibility" - це поведінковий шаблон проектування, який дозволяє об'єкту передавати запит вздовж ланцюга обробників. При отриманні запиту, кожен обробник вирішує або обробляти запит, або передати його наступному обробнику в ланцюгу.
Цей шаблон використовується для досягнення слабкого зв'язування в дизайні програмного забезпечення, де запит від клієнта передається ланцюгу об'єктів для обробки. Запит отримується через обробник, і об'єкти в ланцюгу самі вирішують, хто буде обробляти цей запит.
Шаблон "Chain of Responsibility" є одним з двадцяти трьох відомих шаблонів проектування GoF, які описують загальні рішення для повторюваних проблем проектування при створенні гнучкого та повторно використовуваного об'єктно-орієнтованого програмного забезпечення, тобто об'єктів, які легше реалізувати, змінювати, тестувати та повторно використовувати.
Цей шаблон вирішує проблеми, такі як:
-  	Уникнення зв'язування відправника запиту з його отримувачем.
-  	Можливість обробки запиту більш ніж одним отримувачем.
Шаблон "Chain of Responsibility" описує таке рішення:
-  	Визначте ланцюг об'єктів-отримувачів, які мають відповідальність, залежно від умов виконання в реальному часі, або обробити запит, або передати його наступному отримувачу в ланцюгу (якщо такий є).
-  	Це дозволяє нам відправляти запит до ланцюга отримувачів, не знаючи, хто обробляє запит. Запит передається вздовж ланцюгу, поки отримувач не обробить запит.
-  	Відправник запиту більше не зв'язаний з конкретним отримувачем.

Для шаблону Chain of responsibility була створена Mermaid діаграма (див. рисунок 3):

#### Елементи шаблону:
Шаблон "Chain of Responsibility" складається з наступних ключових елементів:
  -  	Handler Interface або Abstract Class: Це базовий клас, який визначає інтерфейс для обробки запитів і, в багатьох випадках, для створення ланцюга до наступного обробника в послідовності.
  -  	Concrete Handlers: Це класи, які визначають, як будуть оброблятися запити.
  -  	Client: Це об'єкт, який відправляє запит до ланцюга обробників.
Ці елементи взаємодіють таким чином, що клієнт відправляє запит до ланцюга обробників. Кожен обробник в ланцюгу вирішує або обробляти запит, або передати його наступному обробнику в ланцюгу. Запит передається вздовж ланцюгу, поки обробник не обробить запит.
 ```mermaid

classDiagram
    Handler <|-- ConcreteHandler
    Client -- Handler
    class Handler{
        +setNext(Handler)
        +handle(request)
    }
    class ConcreteHandler{
        +handle(request)
    }
    class Client{
        -request
    }



```

Рисунок 3 – Діаграма шаблону Chain of responsibility


### Особливості використання:
Шаблон "Chain of Responsibility" використовується в різних сценаріях, особливо коли потрібно передати запит вздовж ланцюга обробників:
1.	Відокремлення відправника та отримувача: Шаблон "Chain of Responsibility" дозволяє відокремити відправника запиту від його отримувачів. Відправник не повинен знати, який об'єкт обробляє запит, а отримувач не повинен знати структуру ланцюга.
2.	Обробка запитів декількома об'єктами: Шаблон "Chain of Responsibility" дозволяє декільком об'єктам обробляти запит. Кожен обробник в ланцюгу вирішує або обробляти запит, або передати його наступному обробнику в ланцюгу.
3.	Динамічна конфігурація ланцюга обробників: Ланцюг обробників може бути динамічно налаштований в режимі реального часу. Це дозволяє додавати або видаляти обробників без впливу на клієнтський код.
4.	Підтримка різних сценаріїв: Шаблон "Chain of Responsibility" може бути використаний в різних сценаріях, таких як обробка подій, обробка помилок, обробка запитів та інше.
5.	Реальний приклад: Шаблон "Chain of Responsibility" може бути використаний в реальному світі, наприклад, у відділі обслуговування клієнтів з кількома рівнями персоналу підтримки, кожен з яких відповідає за обробку різних типів запитів клієнтів на основі їх складності. 
### Переваги:
	Зменшення зв'язування: Шаблон дозволяє відправити запит до ряду можливих отримувачів, не знаючи, хто в кінцевому підсумку обробить його.
	Додана гнучкість: Шаблон дозволяє динамічно змінювати ланцюг обробників, що додає гнучкості в призначенні обов'язків об'єктам.
	Принцип єдиного обов'язку: Кожен обробник в ланцюгу має єдиний обов'язок, або обробляти запит, або передати його наступному обробнику, що сприяє зрозумілості та легкості утримання коду.
### Недоліки:
	Витрати на виконання: Шаблон "Chain of Responsibility" може ввести додаткові витрати на виконання через операції, необхідні для управління та пошуку об'єктів "Flyweight". Це може потенційно сповільнити час доступу, особливо якщо система часто отримує доступ до великої кількості об'єктів "Flyweight".
	Складність: Шаблон "Chain of Responsibility" може зробити код більш складним, оскільки він вимагає управління спільними об'єктами та передачі зовнішнього стану.

 
# CONCURRENCY PATTERN (Asynchronous method invocation)

### Опис шаблону:
Шаблон "Asynchronous Method Invocation" (AMI), також відомий як асинхронні виклики методів або асинхронний шаблон, - це шаблон проектування, в якому місце виклику не блокується, очікуючи завершення викликаного коду. Замість цього викликаючий потік повідомляється, коли відповідь надходить.
Цей шаблон є шаблоном для асинхронного виклику потенційно тривалих методів об'єкта. Він еквівалентний шаблону IOU ("I owe you"), описаному в 1996 році Алланом Вермейленом.
В більшості мов програмування викликаний метод виконується синхронно, тобто в потоці виконання, з якого він викликаний. Якщо метод займає багато часу для завершення, наприклад, тому що він завантажує дані через Інтернет, викликаючий потік блокується, поки метод не завершиться.
Коли цього не бажано, можна запустити "робочий потік" і викликати метод звідти. У більшості програмних середовищ це вимагає багатьох рядків коду, особливо якщо дбати про уникнення накладних витрат, які можуть виникнути при створенні багатьох потоків.
Шаблон AMI вирішує цю проблему тим, що він доповнює потенційно тривалий ("синхронний") метод об'єкта "асинхронною" варіантом, яка негайно повертається, разом з додатковими методами, які полегшують отримання повідомлення про завершення або очікування завершення в пізніший час.
Для шаблону Asynchronous method invocation була створена Mermaid діаграма 
(див. рисунок 4):

### Елементи шаблону:
  -	Invoker: Це об'єкт, який ініціює асинхронний виклик.
  -  	Asynchronous Method: Це метод, який виконується асинхронно.
  -	Completion Handler: Це об'єкт, який викликається, коли асинхронний метод завершується.
  -	AsyncResult: Це об'єкт, який використовується для отримання результату асинхронного методу.

 ```mermaid


classDiagram
    Invoker -- AsyncResult
    Invoker -- AsynchronousMethod
    AsynchronousMethod -- CompletionHandler
    class Invoker{
        +invokeAsync(AsynchronousMethod)
    }
    class AsynchronousMethod{
        +execute()
    }
    class CompletionHandler{
        +onComplete()
    }
    class AsyncResult{
        -state
        +getState()
    }

```
Рисунок 4 – Діаграма шаблону Asynchronous method invocation

### Переваги:
  -	Покращення продуктивності: Шаблон дозволяє виконувати тривалі операції асинхронно, що покращує продуктивність застосування.
  -	Неблокуючий виклик: Викликаючий потік не блокується, очікуючи завершення викликаного коду.
  -	Гнучкість: Шаблон дозволяє виконувати асинхронні виклики методів без необхідності створювати багато потоків.
### Недоліки:
  -	Складність: Шаблон може зробити код більш складним, оскільки він вимагає управління асинхронними викликами методів.
    -	Витрати на виконання: Шаблон може ввести додаткові витрати на виконання через операції, необхідні для управління та пошуку об'єктів.
  -	Потреба в управлінні станом: Шаблон вимагає управління станом асинхронних викликів, що може бути складним.
### Особливості використання:
Шаблон "Asynchronous Method Invocation" (AMI) використовується в різних сценаріях, особливо коли потрібно виконати тривалі операції без блокування викликаючого потоку. Це може бути корисно в многопоточному програмуванні, веб-браузерах, активних об'єктах, .NET Framework, Java, програмному забезпеченні для обробки зображень, базах даних та серверах.
Шаблон "Asynchronous Method Invocation" дозволяє виконувати тривалі операції асинхронно, що покращує продуктивність застосування. Він додає гнучкості до системи, дозволяючи виконувати асинхронні виклики методів без необхідності створювати багато потоків.
Однак, шаблон "Asynchronous Method Invocation" може зробити код більш складним, оскільки він вимагає управління асинхронними викликами методів. Крім того, він може ввести додаткові витрати на виконання через операції, необхідні для управління та пошуку об'єктів.

